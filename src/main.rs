#![no_std]
#![no_main]
#![feature(type_alias_impl_trait, error_in_core)]

#[macro_use]
extern crate alloc;

use alloc::boxed::Box;
use defmt::{info, warn};
use embedded_graphics::mono_font::{MonoTextStyle, MonoTextStyleBuilder};
use embedded_graphics::text::{Alignment, TextStyle, Text};
use embedded_graphics::text::renderer::CharacterStyle;
use esp_hal::dma::{Dma, DmaDescriptor};
use esp_hal::dma_descriptors;
use esp_hal::gpio::{Input, Io, Level, Output, Pull};
use esp_hal::rng::Rng;
use esp_hal::system::SystemControl;
use esp_hal::timer::systimer::SystemTimer;
use esp_hal::timer::timg::TimerGroup;
use esp_hal::timer::{ErasedTimer, OneShotTimer, PeriodicTimer};
use profont::{PROFONT_18_POINT, PROFONT_24_POINT};
use stack_protection::StackMonitor;

use core::option::Option::*;
use core::{cmp::max, mem::MaybeUninit};

use embedded_hal_bus::spi::ExclusiveDevice;

use embassy_executor::Spawner;
use embassy_net::{
    dns::DnsSocket,
    tcp::client::{TcpClient, TcpClientState},
    Config, Stack, StackResources,
};
use embassy_time::{Duration, Timer};

use reqwless::client::{HttpClient, TlsConfig, TlsVerify};

use embedded_graphics::prelude::*;
use static_cell::make_static;

use esp_println as _;
use esp_backtrace as _;

use esp_hal::{
    clock::ClockControl,
    dma::DmaPriority,
    entry,
    peripherals::Peripherals,
    prelude::*,
    spi::{
        master::{prelude::*, Spi},
        SpiMode,
    },
    FlashSafeDma,
};

use esp_wifi::{
    initialize,
    wifi::{WifiController, WifiDevice, WifiStaDevice},
    EspWifiInitFor,
};

use epd_waveshare::{
    epd7in5b_v3::{Display7in5, Epd7in5, HEIGHT, WIDTH},
    prelude::*,
};

mod config;
mod drawer;
mod irail;
mod merge_relative_order;
mod stack_protection;
mod trains;
mod wifi;

use crate::{drawer::TrainScheduleDrawer, irail::IRailClient, trains::TrainSchedule};
use crate::wifi::WifiConfig;

#[global_allocator]
static ALLOCATOR: esp_alloc::EspHeap = esp_alloc::EspHeap::empty();

fn init_heap() {
    const HEAP_SIZE: usize = 120 * 1024;
    static mut HEAP: MaybeUninit<[u8; HEAP_SIZE]> = MaybeUninit::uninit();

    unsafe {
        ALLOCATOR.init(HEAP.as_mut_ptr() as *mut u8, HEAP_SIZE);
    }
}

fn init_stack_protection() {
    extern "C" {
        static mut _stack_start_cpu0: u8;
        static mut _stack_end_cpu0: u8;
    }

    // We only use a single core for now, so we can write both stack regions.
    let stack_start = unsafe { core::ptr::addr_of!(_stack_start_cpu0) as usize };
    let stack_end = unsafe { core::ptr::addr_of!(_stack_end_cpu0) as usize };
    let _stack_protection = make_static!(StackMonitor::protect(
        stack_start..stack_end
    ));
}

const NUM_SPIDMA_DESCRIPTORS: usize =
    (((epd_waveshare::buffer_len(WIDTH as usize, HEIGHT as usize) + 4091) / 4092) + 1) * 3;

const TIMEZONE: &'static chrono_tz::Tz = &chrono_tz::Europe::Brussels;

// Include config generated by build script
include!(concat!(env!("OUT_DIR"), "/user_config.rs"));

#[embassy_executor::task]
async fn connection(mut controller: WifiController<'static>, config: &'static WifiConfig) {
    info!("start connection task");
    loop {
        let _ = wifi::connection(&mut controller, config).await;
    }
}

#[embassy_executor::task]
async fn net_task(stack: &'static Stack<WifiDevice<'static, WifiStaDevice>>) {
    stack.run().await
}

fn init() {
    init_stack_protection();
    init_heap();
}

#[main]
async fn main(spawner: Spawner) {
    init();

    let peripherals = Peripherals::take();

    let system = SystemControl::new(peripherals.SYSTEM);

    let clocks = ClockControl::max(system.clock_control).freeze();

    let timer = PeriodicTimer::new(
        TimerGroup::new(peripherals.TIMG0, &clocks, None)
            .timer0
            .into(),
    );

    let mut rng = Rng::new(peripherals.RNG);

    let stack_seed = rng.random();
    let tls_seed = rng.random();

    info!("Initializing wifi");

    let init = initialize(
        EspWifiInitFor::Wifi,
        timer,
        rng,
        peripherals.RADIO_CLK,
        &clocks,
    )
    .unwrap();

    let wifi = peripherals.WIFI;
    let (wifi_interface, controller) =
        esp_wifi::wifi::new_with_mode(&init, wifi, WifiStaDevice).unwrap();

    info!("Initializing embassy");

    let timg1 = TimerGroup::new(peripherals.TIMG1, &clocks, None);
    let timer0: ErasedTimer = timg1.timer0.into();
    let timers = [OneShotTimer::new(timer0)];
    let timers = make_static!([OneShotTimer<ErasedTimer>; 1], timers);
    esp_hal_embassy::init(&clocks, timers);


    info!("Initializing dma interrupts");

    let io = Io::new(peripherals.GPIO, peripherals.IO_MUX);
    // let ledpin = gpio.gpio2;
    // let wakeup_pin = gpio.gpio4;

    let sclk = io.pins.gpio12;
    let mosi = io.pins.gpio11;
    let cs = Output::new(io.pins.gpio10, Level::Low);

    let busy = Input::new(io.pins.gpio18, Pull::Up);
    let rst = Output::new(io.pins.gpio16, Level::Low);
    let dc = Output::new(io.pins.gpio17, Level::Low);

    esp_hal::interrupt::enable(
        esp_hal::peripherals::Interrupt::DMA_IN_CH0,
        esp_hal::interrupt::Priority::Priority1,
    )
    .unwrap();
    esp_hal::interrupt::enable(
        esp_hal::peripherals::Interrupt::DMA_OUT_CH0,
        esp_hal::interrupt::Priority::Priority1,
    )
    .unwrap();

    info!("Initializing spi with dma");

    let (tx_descriptors, rx_descriptors) = dma_descriptors!(NUM_SPIDMA_DESCRIPTORS);

    let dma = Dma::new(peripherals.DMA);
    let dma_channel = dma.channel0;
    let spi = Spi::new(peripherals.SPI2, 2u32.MHz(), SpiMode::Mode0, &clocks)
        .with_sck(sclk)
        .with_mosi(mosi)
        .with_dma(
            dma_channel.configure_for_async(false, DmaPriority::Priority0),
            tx_descriptors,
            rx_descriptors,
        );

    let mut spi_device =
        ExclusiveDevice::new(FlashSafeDma::<_, 4>::new(spi), cs, embassy_time::Delay {});

    info!("Initializing Epd");
    let mut epd_driver = Epd7in5::new(&mut spi_device, busy, dc, rst, None)
        .await
        .unwrap();

    info!("Clearing Epd");
    {
        let mut display = Box::new(Display7in5::default());
        let _ = display.clear(TriColor::White).unwrap();

        Text::with_text_style(
            &"Connecting to wifi",
            Point::new(WIDTH as i32/2, 200),
            MonoTextStyle::new(&PROFONT_24_POINT, TriColor::Black),
            TextStyle::with_alignment(Alignment::Center),
        )
        .draw( display.as_mut()).unwrap();

        Text::with_text_style(
            &CONFIG.wifi.ssid,
            Point::new(WIDTH as i32/2, 300),
            MonoTextStyle::new(&PROFONT_24_POINT, TriColor::Chromatic),
            TextStyle::with_alignment(Alignment::Center),
        )
        .draw( display.as_mut()).unwrap();

        let _ = epd_driver
            .update_and_display_frame(&mut spi_device, &display.buffer())
            .await
            .unwrap();

        let _ = epd_driver.wait_until_idle(&mut spi_device).await.unwrap();

        info!("Putting display to sleep");
        let _ = epd_driver.sleep(&mut spi_device).await.unwrap();
    }

    info!("Initializing network stack");
    let net_config = Config::dhcpv4(Default::default());

    // Init network stack
    let stack = &*make_static!(Stack::new(
        wifi_interface,
        net_config,
        make_static!(StackResources::<3>::new()),
        stack_seed.into()
    ));

    info!("Spawning Connection");
    spawner.spawn(connection(controller, &CONFIG.wifi)).ok();
    info!("Spawning Net Task");
    spawner.spawn(net_task(&stack)).ok();
    info!("Spawning Task");

    info!("Setting up wifi");
    loop {
        // wifi::connection(&mut controller, &CONFIG.wifi).await;
        if stack.is_link_up() {
            break;
        }
        Timer::after(Duration::from_millis(500)).await;
    }

    info!("Waiting to get IP address...");
    loop {
        if let Some(config) = stack.config_v4() {
            info!("Got IP: {}", config.address);
            break;
        }
        Timer::after(Duration::from_millis(500)).await;
    }

    info!("Creating http client");

    let mut tls_read_buf = [0; 16640];
    let mut tls_write_buf = [0; 16640];

    let client_state = TcpClientState::<1, 1024, 1024>::new();
    let tcp_client = TcpClient::new(&stack, &client_state);

    let dns = DnsSocket::new(&stack);
    let tls_config = TlsConfig::new(
        tls_seed.into(),
        &mut tls_read_buf,
        &mut tls_write_buf,
        TlsVerify::None,
    );

    let http_client = HttpClient::new_with_tls(&tcp_client, &dns, tls_config);
    let mut irail_client = IRailClient::new(&CONFIG.irail, http_client);

    let limit = Some(4);
    let padding = Size::new(20, 15);
    let size = Size::new(WIDTH, HEIGHT);
    let offset = Point::new(0, 0);
    let retry_time = Duration::from_secs(2);
    let mut next_update_in = Duration::from_secs(90);

    loop {
        // TODO: Enable 'updating' led

        info!("Fetching connections");

        let schedule = match irail_client
            .get_connections(
                &CONFIG.connection.first().unwrap(),
                &CONFIG.connection.last().unwrap(),
                limit.clone(),
            )
            .await
        {
            Ok(connections) => {
                info!("Got connections: {}", connections);
                TrainSchedule::from_connections(connections, &CONFIG.connection.to_vec(), limit)
            }
            Err(err) => {
                warn!("connections error, {:?}. Trying again in {:?} seconds", err, retry_time.as_secs());
                Timer::after(retry_time).await;
                continue;
            }
        };

        let _ = epd_driver.wake_up(&mut spi_device).await.unwrap();
        let _ = epd_driver.wait_until_idle(&mut spi_device).await.unwrap();

        let mut display = Box::new(Display7in5::default());

        let _ = display.clear(TriColor::White).unwrap();

        info!("Filling framebuffer");
        let _ = TrainScheduleDrawer::new(display.as_mut(), &schedule, offset, size, padding)
            .draw()
            .unwrap();

        info!("Draw");
        // Transfer the frame data to the epd and display it
        let _ = epd_driver
            .update_and_display_frame(&mut spi_device, &display.buffer())
            .await
            .unwrap();

        let _ = epd_driver.wait_until_idle(&mut spi_device).await.unwrap();

        info!("Putting display to sleep");
        let _ = epd_driver.sleep(&mut spi_device).await.unwrap();

        info!("Calculating next update");

        if let Some(conn) = schedule.connections.first() {
            if let Some(Some(stop)) = conn.stops.first() {
                let time_until = ((stop.time + stop.delay) - schedule.timestamp)
                    .clamp(chrono::Duration::seconds(2), chrono::Duration::hours(8));

                next_update_in = Duration::from_secs(max(
                    time_until.num_seconds() as u64 / 2,
                    next_update_in.as_secs(),
                ));
            }
        }

        // TODO: Disable 'updating' led
        info!("Next update in: {} seconds", next_update_in.as_secs());
        Timer::after(next_update_in).await;
    }
}
