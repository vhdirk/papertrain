#![no_std]
#![no_main]
#![feature(type_alias_impl_trait)]
#![feature(async_fn_in_trait)]

use config::WifiConfig;
use embassy_net::tcp::{TcpSocket};
use embassy_net::{Config, Stack, StackResources, tcp::client::{TcpClient, TcpClientState}, dns::DnsSocket};
use embassy_net::{Ipv4Address};
use embedded_svc::http;
use esp_backtrace as _;
use esp_println as _;
use defmt::*;
use reqwless::client::{HttpClient, TlsConfig, TlsVerify};

use core::mem::MaybeUninit;
use core::option::Option::*;
use core::str::from_utf8;

// // use {defmt_rtt as _, panic_probe as _}; // global logger

// // use esp_idf_sys as _; // If using the `binstart` feature of `esp-idf-sys`, always keep this module imported
// // use log::*;
// use esp_backtrace as _;
use hal::Rng;
// use log::*;

use embassy_executor::Spawner;
use embassy_executor::_export::StaticCell;

use embassy_time::{Duration, Timer};

use hal::embassy::executor::Executor;
use hal::{
    clock::ClockControl,
    embassy::{self},
    interrupt,
    peripherals::{Interrupt, Peripherals, UART0},
    prelude::*,
    systimer::SystemTimer,
    Uart,
    timer::TimerGroup,
    Delay,
};

use embedded_svc::wifi::{AuthMethod, ClientConfiguration, Configuration};

use esp_wifi::{
    initialize,
    wifi::{WifiController, WifiDevice, WifiEvent, WifiMode, WifiState},
    EspWifiInitFor,
};
use epd_waveshare::{
    prelude::*,
    epd7in5b_v2::{Epd7in5, HEIGHT as DISPLAY_HEIGHT, WIDTH as DISPLAY_WIDTH},
    graphics::VarDisplay,
};

mod config;
mod irail;

macro_rules! singleton {
    ($val:expr) => {{
        type T = impl Sized;
        static STATIC_CELL: StaticCell<T> = StaticCell::new();
        let (x,) = STATIC_CELL.init(($val,));
        x
    }};
}


static EXECUTOR: StaticCell<Executor> = StaticCell::new();

#[global_allocator]
static ALLOCATOR: esp_alloc::EspHeap = esp_alloc::EspHeap::empty();

fn init_heap() {
    const HEAP_SIZE: usize = 32 * 1024;
    static mut HEAP: MaybeUninit<[u8; HEAP_SIZE]> = MaybeUninit::uninit();

    unsafe {
        ALLOCATOR.init(HEAP.as_mut_ptr() as *mut u8, HEAP_SIZE);
    }
}

// // use esp_idf_hal::delay::Delay;
// // use esp_idf_hal::gpio;
// // use esp_idf_hal::gpio::*;
// // use esp_idf_hal::modem::Modem;
// // use esp_idf_hal::peripherals::Peripherals;
// // use esp_idf_hal::prelude::*;
// // use esp_idf_hal::spi;
// // use esp_idf_hal::spi::{SpiDeviceDriver, SpiDriver};

// // use esp_idf_svc::eventloop::EspSystemEventLoop;
// // use esp_idf_svc::nvs::EspDefaultNvsPartition;

// // use std::thread::sleep;
// // use std::time::Duration;



// // mod wifi;

use crate::config::AppConfig;
// use crate::irail::IRailClient;

// // type SpiDev = SpiDeviceDriver<'static, SpiDriver<'static>>;

// // type EpdDriver = Epd7in5<
// //     SpiDev,
// //     PinDriver<'static, AnyInputPin, Input>,
// //     PinDriver<'static, AnyOutputPin, Output>,
// //     PinDriver<'static, AnyOutputPin, Output>,
// //     Delay,
// // >;

// Include config generated by build script
include!(concat!(env!("OUT_DIR"), "/user_config.rs"));

#[embassy_executor::task]
async fn connection(mut controller: WifiController<'static>, config: &'static WifiConfig) {
    use embedded_svc::wifi::Wifi;

    println!("start connection task");
    // println!("Device capabilities: {:?}", controller.get_capabilities());
    loop {
        match esp_wifi::wifi::get_wifi_state() {
            WifiState::StaConnected => {
                // wait until we're no longer connected
                controller.wait_for_event(WifiEvent::StaDisconnected).await;
                Timer::after(Duration::from_millis(5000)).await
            }
            _ => {}
        }
        if !matches!(controller.is_started(), Ok(true)) {
            let client_config = Configuration::Client(ClientConfiguration {
                ssid: config.ssid.into(),
                password: config.password.into(),
                auth_method: config.auth_method,
                channel: config.channel,
                ..Default::default()
            });
            controller.set_configuration(&client_config).unwrap();
            println!("Starting wifi");
            controller.start().await.unwrap();
            println!("Wifi started!");
        }
        println!("About to connect...");

        match controller.connect().await {
            Ok(_) => println!("Wifi connected!"),
            Err(e) => {
                println!("Failed to connect to wifi: {:?}", e);
                Timer::after(Duration::from_millis(5000)).await
            }
        }
    }
}

#[embassy_executor::task]
async fn net_task(stack: &'static Stack<WifiDevice<'static>>) {
    stack.run().await
}


// #[embassy_executor::task]
// async fn task(stack: &'static Stack<WifiDevice<'static>>) {
//     let mut rx_buffer = [0; 4096];
//     let mut tx_buffer = [0; 4096];

//     loop {
//         if stack.is_link_up() {
//             break;
//         }
//         Timer::after(Duration::from_millis(500)).await;
//     }

//     println!("Waiting to get IP address...");
//     loop {
//         if let Some(config) = stack.config_v4() {
//             println!("Got IP: {}", config.address);
//             break;
//         }
//         Timer::after(Duration::from_millis(500)).await;
//     }

//     loop {
//         Timer::after(Duration::from_millis(1_000)).await;

//         let mut socket = TcpSocket::new(&stack, &mut rx_buffer, &mut tx_buffer);

//         socket.set_timeout(Some(embassy_time::Duration::from_secs(10)));

//         let remote_endpoint = (Ipv4Address::new(142, 250, 185, 115), 80);
//         println!("connecting...");
//         let r = socket.connect(remote_endpoint).await;
//         if let Err(e) = r {
//             println!("connect error: {:?}", e);
//             continue;

//         }

//         // let mut client = HttpClient::new(&socket., StaticDns); // Types implementing embedded-nal-async

//         println!("connected!");
//         let mut buf = [0; 1024];
//         loop {
//             let r = socket
//                 .write(b"GET / HTTP/1.0\r\nHost: www.mobile-j.de\r\n\r\n")
//                 .await;
//             if let Err(e) = r {
//                 println!("write error: {:?}", e);
//                 break;
//             }
//             let n = match socket.read(&mut buf).await {
//                 Ok(0) => {
//                     println!("read EOF");
//                     break;
//                 }
//                 Ok(n) => n,
//                 Err(e) => {
//                     println!("read error: {:?}", e);
//                     break;
//                 }
//             };
//             println!("{}", core::str::from_utf8(&buf[..n]).unwrap());
//         }
//         Timer::after(Duration::from_millis(3000)).await;
//     }
// }


#[embassy_executor::task]
async fn task(stack: &'static Stack<WifiDevice<'static>>) {
    let mut rx_buffer = [0; 1024];
    let mut tls_read_buffer = [0; 1024];
    let mut tls_write_buffer = [0; 1024];

    loop {
        if stack.is_link_up() {
            break;
        }
        Timer::after(Duration::from_millis(500)).await;
    }

    println!("Waiting to get IP address...");
    loop {
        if let Some(config) = stack.config_v4() {
            println!("Got IP: {}", config.address);
            break;
        }
        Timer::after(Duration::from_millis(500)).await;
    }

    loop {
        let client_state = TcpClientState::<1,1024,1024>::new();
        let tcp_client = TcpClient::new(&stack, &client_state);
        let dns = DnsSocket::new(&stack);
        let tls_config = TlsConfig::new(123456778_u64, &mut tls_read_buffer, &mut tls_write_buffer, TlsVerify::None);
        let mut http_client = HttpClient::new_with_tls(&tcp_client, &dns, tls_config);
        let mut request = http_client.request(reqwless::request::Method::GET, "https://google.com").await.unwrap();

        let response = request.send(&mut rx_buffer).await.unwrap();
        println!("Http result: {:?}",response.status);

        let body = from_utf8(response.body().read_to_end().await.unwrap()).unwrap();
        println!("Http body: {}",body);

        Timer::after(Duration::from_millis(3000)).await;
    }
}

#[entry]
fn main() -> ! {
    init_heap();

    let peripherals = Peripherals::take();

    let mut system = peripherals.SYSTEM.split();
    let clocks = ClockControl::max(system.clock_control).freeze();

    let timer = hal::timer::TimerGroup::new(
        peripherals.TIMG1,
        &clocks,
        &mut system.peripheral_clock_control,
    )
    .timer0;

    let mut rng = Rng::new(peripherals.RNG);
    let seed = rng.random();

    let init = initialize(
        EspWifiInitFor::Wifi,
        timer,
        rng,
        system.radio_clock_control,
        &clocks,
    )
    .unwrap();

    let (wifi, ..) = peripherals.RADIO.split();
    let (wifi_interface, controller) =
        esp_wifi::wifi::new_with_mode(&init, wifi, WifiMode::Sta).unwrap();

    embassy::init(
        &clocks,
        SystemTimer::new(peripherals.SYSTIMER),
    );

    let net_config = embassy_net::Config::dhcpv4(Default::default());

    // Init network stack
    let stack = &*singleton!(embassy_net::Stack::new(
        wifi_interface,
        net_config,
        singleton!(embassy_net::StackResources::<3>::new()),
        seed.into()
    ));


    let executor = EXECUTOR.init(Executor::new());
    executor.run(|spawner| {
        info!("Spawning Connection");
        spawner.spawn(connection(controller, &CONFIG.wifi)).ok();
        info!("Spawning Net Task");
        spawner.spawn(net_task(&stack)).ok();
        println!("Spawning Task");
        spawner.spawn(task(&stack)).ok();
        println!("Spawning finished");
    })

//     //     let (_led_pin, wakeup_pin, modem, spi_driver, epd, delay) = gather_peripherals(peripherals)?;

//     //     let sysloop = EspSystemEventLoop::take()?;
//     //     let nvs = EspDefaultNvsPartition::take()?;

//     //     // see comment on function
//     //     //disable_onboard_led(led_pin)?;

//     //     // start wifi
//     //     // TODO: display error icon on screen and sleep again
//     //     let wifi = wifi::wifi(&CONFIG.wifi, modem, sysloop, nvs).expect("failed to connect to wifi");

//     //     // get image
//     //     log::info!("request image from server");
//     //     let mut client = IRailClient::new(CONFIG.irail.clone())?;

//     //     let connections = CONFIG
//     //         .connections
//     //         .map(|conn| client.get_connections(conn.from, conn.to));

//     //     log::info!("Got connection {:?}", connections[0].as_ref().unwrap());

//     //     // TODO: generate image from connections

//     //     // turn off wifi
//     //     log::info!("turning off wifi");
//     //     drop(wifi);

//     //     // TODO: draw the image

//     //     // if let Ok(image_data) = image_result {
//     //     //     log::info!("render image");
//     //     //     draw_epd(image_data, spi_driver, epd, delay)?;
//     //     // } else {
//     //     //     log::error!("getting image data failed: {:?}", image_result.unwrap_err());
//     //     // }

//     //     // deep sleep for 2 minutes (or on wakeup button press)
//     //     // TODO: sleep time should depend on train hours. The closer to departure, the more refreshes
//     //     enter_deep_sleep(wakeup_pin.into(), Duration::from_secs(60 * 2));

//     //     unreachable!("in sleep");
}

// // fn gather_peripherals(
// //     peripherals: Peripherals,
// // ) -> anyhow::Result<(Gpio2, Gpio4, Modem, SpiDev, EpdDriver, Delay)> {
// //     let pins = peripherals.pins;
// //     let ledpin = pins.gpio2;
// //     let wakeup_pin = pins.gpio4;

// //     let modem = peripherals.modem;

// //     let spi_p = peripherals.spi3;
// //     let sclk: AnyOutputPin = pins.gpio13.into();
// //     let sdo: AnyOutputPin = pins.gpio14.into();
// //     let cs: AnyOutputPin = pins.gpio15.into();
// //     let busy_in: AnyInputPin = pins.gpio35.into();
// //     let rst: AnyOutputPin = pins.gpio26.into();
// //     let dc: AnyOutputPin = pins.gpio27.into();

// //     info!("create epd driver");
// //     let (spi_driver, epd, delay) = create_epd_driver(spi_p, sclk, sdo, cs, busy_in, rst, dc)?;

// //     Ok((ledpin, wakeup_pin, modem, spi_driver, epd, delay))
// // }

// // fn enter_deep_sleep(wakeup_pin: AnyInputPin, sleep_time: Duration) {
// //     // let wakeup_pin = PinDriver::input(wakeup_pin).expect("wakeup pin sleep");
// //     // unsafe {
// //     //     esp_idf_sys::esp_sleep_enable_ext0_wakeup(wakeup_pin.pin(), 0);
// //     // }
// //     info!("entering deep sleep");
// //     unsafe {
// //         // TODO: measure current draw vs gpio_deep_sleep_hold_en
// //         //esp_idf_sys::rtc_gpio_hold_en(led.pin());
// //         //esp_idf_sys::gpio_deep_sleep_hold_en()
// //         // TODO see if these need to be configured or if it makes a difference at all
// //         // esp_sleep_pd_config(ESP_PD_DOMAIN_RTC_PERIPH, ESP_PD_OPTION_OFF);
// //         // esp_sleep_pd_config(ESP_PD_DOMAIN_RTC_SLOW_MEM, ESP_PD_OPTION_OFF);
// //         // esp_sleep_pd_config(ESP_PD_DOMAIN_RTC_FAST_MEM, ESP_PD_OPTION_OFF);
// //         // esp_sleep_pd_config(ESP_PD_DOMAIN_XTAL, ESP_PD_OPTION_OFF);

// //         esp_idf_sys::esp_deep_sleep(sleep_time.as_micros() as u64);
// //     }
// //     // unreachable!("we will be asleep by now");
// // }

// // /// Disable the onboard led during deep sleep
// // /// TODO: measure current draw vs gpio_deep_sleep_hold_en
// // pub fn disable_onboard_led(ledpin: gpio::Gpio2) -> anyhow::Result<()> {
// //     log::info!("disable onboard led");
// //     let mut led = PinDriver::output(ledpin)?;
// //     led.set_low()?;
// //     unsafe {
// //         esp_idf_sys::rtc_gpio_hold_en(led.pin());
// //     }

// //     Ok(())
// // }

// // fn create_epd_driver(
// //     spi_p: spi::SPI3,
// //     sclk: AnyOutputPin,
// //     sdo: AnyOutputPin,
// //     _cs: AnyOutputPin,
// //     busy_in: AnyInputPin,
// //     rst: AnyOutputPin,
// //     dc: AnyOutputPin,
// // ) -> anyhow::Result<(SpiDev, EpdDriver, Delay)> {
// //     let mut driver = spi::SpiDeviceDriver::new_single(
// //         spi_p,
// //         sclk,
// //         sdo,
// //         Option::<gpio::AnyIOPin>::None,
// //         Option::<gpio::AnyOutputPin>::None,
// //         &spi::config::DriverConfig::new(),
// //         &spi::config::Config::new().baudrate(10.MHz().into()),
// //     )?;

// //     info!("driver setup completed");
// //     let mut delay = Delay::new_default();

// //     // Setup EPD
// //     let epd_driver = Epd7in5::new(
// //         &mut driver,
// //         PinDriver::input(busy_in)?,
// //         PinDriver::output(dc)?,
// //         PinDriver::output(rst)?,
// //         &mut delay,
// //         None,
// //     )
// //     .unwrap();

// //     info!("epd setup completed");

// //     Ok((driver, epd_driver, delay))
// // }

// // /// Retuns the size of a buffer necessary to hold the entire image
// // pub fn get_buffer_size() -> usize {
// //     // The height is multiplied by 2 because the red pixels essentially exist on a separate "layer"
// //     epd_waveshare::buffer_len(DISPLAY_WIDTH as usize, DISPLAY_HEIGHT as usize * 2)
// // }

// // fn draw_epd(
// //     mut buffer: Vec<u8>,
// //     mut driver: SpiDev,
// //     mut epd: EpdDriver,
// //     mut delay: Delay,
// // ) -> anyhow::Result<()> {
// //     let expected_len = get_buffer_size();

// //     // check that what we got from the server is actually the same size as when me make a
// //     // epd_waveshare buffer of size WIDTH*HEIGHT pixels
// //     let buffer_len = buffer.len();
// //     if buffer_len != expected_len {
// //         anyhow::bail!("buffer len expected {}, got {}", expected_len, buffer_len);
// //     }
// //     let display = VarDisplay::<TriColor>::new(DISPLAY_WIDTH, DISPLAY_HEIGHT, &mut buffer, false)
// //         .expect("failed to create display");

// //     epd.update_and_display_frame(&mut driver, display.buffer(), &mut delay)
// //         .expect("display frame");
// //     info!("called display frame");
// //     delay.delay_ms(20_000u32);

// //     info!("done waiting, putting display to sleep");
// //     epd.sleep(&mut driver, &mut delay).expect("failed to sleep");

// //     Ok(())
// // }



// #[entry]
// fn main() -> ! {
//     let peripherals = Peripherals::take();
//     let system = peripherals.SYSTEM.split();
//     let clocks = ClockControl::max(system.clock_control).freeze();
//     let mut delay = Delay::new(&clocks);

//     defmt::println!("Hello world pr!");
//     defmt::warn!("Hello world!");
//     loop {
//         defmt::info!("Hello world!");

//         // println!("Loop...");
//         delay.delay_ms(500u32);
//     }
// }
