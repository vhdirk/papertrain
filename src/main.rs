#![no_std]
#![no_main]
#![feature(type_alias_impl_trait, async_fn_in_trait, error_in_core)]

#[macro_use]
extern crate alloc;

use alloc::boxed::Box;

use core::option::Option::*;
use core::{cmp::max, mem::MaybeUninit};

use defmt::*;

use embedded_hal_bus::spi::ExclusiveDevice;

use embassy_executor::Spawner;
use embassy_net::{
    dns::DnsSocket,
    tcp::client::{TcpClient, TcpClientState},
    Config, Stack, StackResources,
};
use embassy_time::{Duration, Timer};

use reqwless::client::{HttpClient, TlsConfig, TlsVerify};

use embedded_graphics::prelude::*;
use static_cell::make_static;

use esp_println as _;
use esp_backtrace as _;

use esp_hal::{
    clock::ClockControl,
    dma::DmaPriority,
    embassy::{self},
    entry,
    gdma::Gdma,
    gpio::IO,
    peripherals::Peripherals,
    prelude::*,
    spi::{
        master::{prelude::*, Spi},
        SpiMode,
    },
    systimer::SystemTimer,
    timer::TimerGroup,
    FlashSafeDma, Rng,
};

use esp_wifi::{
    initialize,
    wifi::{WifiController, WifiDevice, WifiStaDevice},
    EspWifiInitFor,
};

use epd_waveshare::{
    epd7in5b_v3::{Display7in5, Epd7in5, HEIGHT, WIDTH},
    prelude::*,
};

mod config;
mod drawer;
mod irail;
mod merge_relative_order;
mod stack_protection;
mod trains;
mod wifi;

use crate::{drawer::TrainScheduleDrawer, irail::IRailClient, trains::TrainSchedule};
use crate::wifi::WifiConfig;

#[global_allocator]
static ALLOCATOR: esp_alloc::EspHeap = esp_alloc::EspHeap::empty();

fn init_heap() {
    const HEAP_SIZE: usize = 120 * 1024;
    static mut HEAP: MaybeUninit<[u8; HEAP_SIZE]> = MaybeUninit::uninit();

    unsafe {
        ALLOCATOR.init(HEAP.as_mut_ptr() as *mut u8, HEAP_SIZE);
    }
}

fn init_stack_protection() {
    extern "C" {
        static mut _stack_start_cpu0: u8;
        static mut _stack_end_cpu0: u8;
    }

    // We only use a single core for now, so we can write both stack regions.
    let stack_start = unsafe { core::ptr::addr_of!(_stack_start_cpu0) as usize };
    let stack_end = unsafe { core::ptr::addr_of!(_stack_end_cpu0) as usize };
    let _stack_protection = make_static!(crate::stack_protection::StackMonitor::protect(
        stack_start..stack_end
    ));
}

const NUM_SPIDMA_DESCRIPTORS: usize =
    (((epd_waveshare::buffer_len(WIDTH as usize, HEIGHT as usize) + 4091) / 4092) + 1) * 3;

const TIMEZONE: &'static chrono_tz::Tz = &chrono_tz::Europe::Brussels;

// Include config generated by build script
include!(concat!(env!("OUT_DIR"), "/user_config.rs"));

#[embassy_executor::task]
async fn connection(mut controller: WifiController<'static>, config: &'static WifiConfig) {
    info!("start connection task");
    loop {
        let _ = wifi::connection(&mut controller, config).await;
    }
}

#[embassy_executor::task]
async fn net_task(stack: &'static Stack<WifiDevice<'static, WifiStaDevice>>) {
    stack.run().await
}

fn init() {
    init_stack_protection();
    init_heap();
}

#[main]
async fn main(spawner: Spawner) -> ! {
    init();

    let peripherals = Peripherals::take();

    let system = peripherals.SYSTEM.split();

    let clocks = ClockControl::max(system.clock_control).freeze();
    let timer = TimerGroup::new(peripherals.TIMG1, &clocks).timer0;

    let mut rng = Rng::new(peripherals.RNG);

    let stack_seed = rng.random();
    let tls_seed = rng.random();

    info!("Initializing wifi");

    let init = initialize(
        EspWifiInitFor::Wifi,
        timer,
        rng,
        system.radio_clock_control,
        &clocks,
    )
    .unwrap();

    let wifi = peripherals.WIFI;
    let (wifi_interface, controller) =
        esp_wifi::wifi::new_with_mode(&init, wifi, WifiStaDevice).unwrap();

    info!("Initializing embassy");

    embassy::init(&clocks, SystemTimer::new(peripherals.SYSTIMER));

    info!("Initializing dma interrupts");

    let io = IO::new(peripherals.GPIO, peripherals.IO_MUX);
    // let ledpin = gpio.gpio2;
    // let wakeup_pin = gpio.gpio4;

    let sclk = io.pins.gpio12.into_push_pull_output();
    let mosi = io.pins.gpio11.into_push_pull_output();
    let cs = io.pins.gpio10.into_push_pull_output();

    let busy = io.pins.gpio18.into_pull_up_input();
    let rst = io.pins.gpio16.into_push_pull_output();
    let dc = io.pins.gpio17.into_push_pull_output();

    esp_hal::interrupt::enable(
        esp_hal::peripherals::Interrupt::DMA_IN_CH0,
        esp_hal::interrupt::Priority::Priority1,
    )
    .unwrap();
    esp_hal::interrupt::enable(
        esp_hal::peripherals::Interrupt::DMA_OUT_CH0,
        esp_hal::interrupt::Priority::Priority1,
    )
    .unwrap();

    info!("Initializing spi with dma");
    let mut tx_descriptors = [0u32; NUM_SPIDMA_DESCRIPTORS];
    let mut rx_descriptors = [0u32; NUM_SPIDMA_DESCRIPTORS];
    let dma = Gdma::new(peripherals.DMA);
    let spi = Spi::new(peripherals.SPI2, 2u32.MHz(), SpiMode::Mode0, &clocks)
        .with_sck(sclk)
        .with_mosi(mosi)
        .with_dma(dma.channel0.configure(
            false,
            &mut tx_descriptors,
            &mut rx_descriptors,
            DmaPriority::Priority0,
        ));
    let mut spi_device =
        ExclusiveDevice::new(FlashSafeDma::<_, 4>::new(spi), cs, embassy_time::Delay {});

    info!("Initializing Epd");
    let mut epd_driver = Epd7in5::new(&mut spi_device, busy, dc, rst, None)
        .await
        .unwrap();

    info!("Clearing Epd");
    let _ = epd_driver.clear_frame(&mut spi_device).await.unwrap();
    let _ = epd_driver.wait_until_idle(&mut spi_device).await.unwrap();

    info!("Initializing network stack");
    let net_config = Config::dhcpv4(Default::default());

    // Init network stack
    let stack = &*make_static!(Stack::new(
        wifi_interface,
        net_config,
        make_static!(StackResources::<3>::new()),
        stack_seed.into()
    ));

    info!("Spawning Connection");
    spawner.spawn(connection(controller, &CONFIG.wifi)).ok();
    info!("Spawning Net Task");
    spawner.spawn(net_task(&stack)).ok();
    info!("Spawning Task");

    info!("Setting up wifi");
    loop {
        // wifi::connection(&mut controller, &CONFIG.wifi).await;
        if stack.is_link_up() {
            break;
        }
        Timer::after(Duration::from_millis(500)).await;
    }

    info!("Waiting to get IP address...");
    loop {
        if let Some(config) = stack.config_v4() {
            info!("Got IP: {}", config.address);
            break;
        }
        Timer::after(Duration::from_millis(500)).await;
    }

    info!("Creating http client");

    let mut tls_read_buf = [0; 16640];
    let mut tls_write_buf = [0; 16640];

    let client_state = TcpClientState::<1, 1024, 1024>::new();
    let tcp_client = TcpClient::new(&stack, &client_state);

    let dns = DnsSocket::new(&stack);
    let tls_config = TlsConfig::new(
        tls_seed.into(),
        &mut tls_read_buf,
        &mut tls_write_buf,
        TlsVerify::None,
    );

    let http_client = HttpClient::new_with_tls(&tcp_client, &dns, tls_config);
    let mut irail_client = IRailClient::new(&CONFIG.irail, http_client);

    let limit = Some(4);
    let padding = Size::new(20, 15);
    let size = Size::new(WIDTH, HEIGHT);
    let offset = Point::new(0, 0);
    let retry_time = Duration::from_secs(2);
    let mut next_update_in = Duration::from_secs(90);

    loop {
        // TODO: Enable 'updating' led

        info!("Fetching connections");

        let schedule = match irail_client
            .get_connections(
                &CONFIG.connection.first().unwrap(),
                &CONFIG.connection.last().unwrap(),
                limit.clone(),
            )
            .await
        {
            Ok(connections) => {
                info!("Got connections: {}", connections);
                TrainSchedule::from_connections(connections, &CONFIG.connection.to_vec(), limit)
            }
            Err(err) => {
                warn!("connections error, {:?}. Trying again in {:?} seconds", err, retry_time.as_secs());
                Timer::after(retry_time).await;
                continue;
            }
        };

        let _ = epd_driver.wake_up(&mut spi_device).await.unwrap();
        let _ = epd_driver.wait_until_idle(&mut spi_device).await.unwrap();

        let mut display = Box::new(Display7in5::default());

        let _ = display.clear(TriColor::White).unwrap();

        info!("Filling framebuffer");
        let _ = TrainScheduleDrawer::new(display.as_mut(), &schedule, offset, size, padding)
            .draw()
            .unwrap();

        info!("Draw");
        // Transfer the frame data to the epd and display it
        let _ = epd_driver
            .update_and_display_frame(&mut spi_device, &display.buffer())
            .await
            .unwrap();

        let _ = epd_driver.wait_until_idle(&mut spi_device).await.unwrap();

        info!("Putting display to sleep");
        let _ = epd_driver.sleep(&mut spi_device).await.unwrap();

        info!("Calculating next update");

        if let Some(conn) = schedule.connections.first() {
            if let Some(Some(stop)) = conn.stops.first() {
                let time_until = ((stop.time + stop.delay) - schedule.timestamp)
                    .clamp(chrono::Duration::seconds(2), chrono::Duration::hours(8));

                next_update_in = Duration::from_secs(max(
                    time_until.num_seconds() as u64 / 2,
                    next_update_in.as_secs(),
                ));
            }
        }

        // TODO: Disable 'updating' led
        info!("Next update in: {} seconds", next_update_in.as_secs());
        Timer::after(next_update_in).await;
    }
}
