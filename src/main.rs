#![no_std]
#![no_main]
#![feature(type_alias_impl_trait)]
#![feature(async_fn_in_trait)]

#[macro_use]
extern crate alloc;
// use {defmt_rtt as _, panic_probe as _}; // global logger


use config::AppConfig;
use wifi::WifiConfig;

use log::*;
use embassy_futures::select::select;
use embassy_net::{
    dns::DnsSocket,
    tcp::client::{TcpClient, TcpClientState},
    Stack,
};
use epd_waveshare;
use esp_backtrace as _;
use esp_println::{self as _, println};
use reqwless::{client::{HttpClient, TlsConfig, TlsVerify}, request::Method};

use core::mem::MaybeUninit;
use core::option::Option::*;
use core::str::from_utf8;

use hal::{Rng, entry};

use embassy_executor::_export::StaticCell;

use embassy_time::{Duration, Timer};

use hal::embassy::executor::Executor;
use hal::{
    clock::ClockControl,
    embassy::{self},
    peripherals::Peripherals,
    // spi::Spi,
    systimer::SystemTimer,
    prelude::*
};

use epd_waveshare::{
    epd7in5b_v2::{Epd7in5, HEIGHT as DISPLAY_HEIGHT, WIDTH as DISPLAY_WIDTH},
    graphics::VarDisplay,
    prelude::*,
};
use esp_wifi::{
    initialize,
    wifi::{WifiController, WifiDevice, WifiMode},
    EspWifiInitFor,
};

use crate::irail::IRailClient;

mod config;
mod irail;
mod wifi;

macro_rules! singleton {
    ($val:expr) => {{
        type T = impl Sized;
        static STATIC_CELL: StaticCell<T> = StaticCell::new();
        let (x,) = STATIC_CELL.init(($val,));
        x
    }};
}

static EXECUTOR: StaticCell<Executor> = StaticCell::new();

#[global_allocator]
static ALLOCATOR: esp_alloc::EspHeap = esp_alloc::EspHeap::empty();

fn init_heap() {
    const HEAP_SIZE: usize = 32 * 1024;
    static mut HEAP: MaybeUninit<[u8; HEAP_SIZE]> = MaybeUninit::uninit();

    unsafe {
        ALLOCATOR.init(HEAP.as_mut_ptr() as *mut u8, HEAP_SIZE);
    }
}

// use crate::irail::IRailClient;

// type SpiDev = SpiDeviceDriver<'static, SpiDriver<'static>>;

// type EpdDriver = Epd7in5<
//     Spi,
//     PinDriver<'static, AnyInputPin, Input>,
//     PinDriver<'static, AnyOutputPin, Output>,
//     PinDriver<'static, AnyOutputPin, Output>,
//     Delay,
// >;

// Include config generated by build script
include!(concat!(env!("OUT_DIR"), "/user_config.rs"));

#[embassy_executor::task]
async fn connection(mut controller: WifiController<'static>, config: &'static WifiConfig) {
    info!("start connection task");
    // info!("Device capabilities: {:?}", controller.get_capabilities());
    loop {
        wifi::connection(&mut controller, config).await
    }
}

#[embassy_executor::task]
async fn net_task(stack: &'static Stack<WifiDevice<'static>>) {

    select(stack.run(), async {
                // HACK: force polling the interface in case some write operation doesn't wake it up
                loop {
                    Timer::after(Duration::from_secs(1)).await;
                }
            })
            .await;
    // stack.run().await
}

#[embassy_executor::task]
async fn task(stack: &'static Stack<WifiDevice<'static>>) {
    info!("Setting up wifi");

    loop {
        // wifi::connection(&mut controller, &CONFIG.wifi).await;
        if stack.is_link_up() {
            break;
        }
        Timer::after(Duration::from_millis(500)).await;
    }

    info!("Waiting to get IP address...");
    loop {
        if let Some(config) = stack.config_v4() {
            info!("Got IP: {}", config.address);
            break;
        }
        Timer::after(Duration::from_millis(500)).await;
    }

    loop {
        info!("Creating http client");

        let client_state = TcpClientState::<1, 1024, 1024>::new();
        let tcp_client = TcpClient::new(&stack, &client_state);
        let dns = DnsSocket::new(&stack);

        let http_client = HttpClient::new(&tcp_client, &dns);


        info!("Fetching connections");

        let mut irail_client = IRailClient::new(&CONFIG.irail, http_client);
        let connections = irail_client.get_connections(&CONFIG.connections[0].from, &CONFIG.connections[0].to).await;

        Timer::after(Duration::from_millis(3000)).await;
    }
}

#[entry]
fn main() -> ! {
    init_heap();

    esp_println::logger::init_logger_from_env();
    log::info!("Logger is setup");
    println!("Logger is setup");

    let peripherals = Peripherals::take();

    let mut system = peripherals.SYSTEM.split();
    let clocks = ClockControl::max(system.clock_control).freeze();

    let timer = hal::timer::TimerGroup::new(peripherals.TIMG1, &clocks).timer0;

    let mut rng = Rng::new(peripherals.RNG);
    let seed = rng.random();

    let init = initialize(
        EspWifiInitFor::Wifi,
        timer,
        rng,
        system.radio_clock_control,
        &clocks,
    )
    .unwrap();

    let wifi = peripherals.WIFI;
    let (wifi_interface, controller) =
        esp_wifi::wifi::new_with_mode(&init, wifi, WifiMode::Sta).unwrap();

    embassy::init(&clocks, SystemTimer::new(peripherals.SYSTIMER));

    let net_config = embassy_net::Config::dhcpv4(Default::default());

    // Init network stack
    let stack = &*singleton!(embassy_net::Stack::new(
        wifi_interface,
        net_config,
        singleton!(embassy_net::StackResources::<3>::new()),
        seed.into()
    ));

    let executor = EXECUTOR.init(Executor::new());
    executor.run(|spawner| {
        info!("Spawning Connection");
        spawner.spawn(connection(controller, &CONFIG.wifi)).ok();
        info!("Spawning Net Task");
        spawner.spawn(net_task(&stack)).ok();
        info!("Spawning Task");
        spawner.spawn(task(&stack)).ok();
        info!("Spawning finished");
    })

    //     //     let (_led_pin, wakeup_pin, modem, spi_driver, epd, delay) = gather_peripherals(peripherals)?;

    //     //     let sysloop = EspSystemEventLoop::take()?;
    //     //     let nvs = EspDefaultNvsPartition::take()?;

    //     //     // see comment on function
    //     //     //disable_onboard_led(led_pin)?;

    //     //     // start wifi
    //     //     // TODO: display error icon on screen and sleep again
    //     //     let wifi = wifi::wifi(&CONFIG.wifi, modem, sysloop, nvs).expect("failed to connect to wifi");

    //     //     // get image
    //     //     log::info!("request image from server");
    //     //     let mut client = IRailClient::new(CONFIG.irail.clone())?;

    //     //     let connections = CONFIG
    //     //         .connections
    //     //         .map(|conn| client.get_connections(conn.from, conn.to));

    //     //     log::info!("Got connection {:?}", connections[0].as_ref().unwrap());

    //     //     // TODO: generate image from connections

    //     //     // turn off wifi
    //     //     log::info!("turning off wifi");
    //     //     drop(wifi);

    //     //     // TODO: draw the image

    //     //     // if let Ok(image_data) = image_result {
    //     //     //     log::info!("render image");
    //     //     //     draw_epd(image_data, spi_driver, epd, delay)?;
    //     //     // } else {
    //     //     //     log::error!("getting image data failed: {:?}", image_result.unwrap_err());
    //     //     // }

    //     //     // deep sleep for 2 minutes (or on wakeup button press)
    //     //     // TODO: sleep time should depend on train hours. The closer to departure, the more refreshes
    //     //     enter_deep_sleep(wakeup_pin.into(), Duration::from_secs(60 * 2));

    //     //     unreachable!("in sleep");
}

// fn gather_peripherals(
//     peripherals: Peripherals,
// ) -> anyhow::Result<(Gpio2, Gpio4, Modem, SpiDev, EpdDriver, Delay)> {
//     let pins = peripherals.pins;
//     let ledpin = pins.gpio2;
//     let wakeup_pin = pins.gpio4;

//     let modem = peripherals.modem;

//     let spi_p = peripherals.spi3;
//     let sclk: AnyOutputPin = pins.gpio13.into();
//     let sdo: AnyOutputPin = pins.gpio14.into();
//     let cs: AnyOutputPin = pins.gpio15.into();
//     let busy_in: AnyInputPin = pins.gpio35.into();
//     let rst: AnyOutputPin = pins.gpio26.into();
//     let dc: AnyOutputPin = pins.gpio27.into();

//     info!("create epd driver");
//     let (spi_driver, epd, delay) = create_epd_driver(spi_p, sclk, sdo, cs, busy_in, rst, dc)?;

//     Ok((ledpin, wakeup_pin, modem, spi_driver, epd, delay))
// }

// // fn enter_deep_sleep(wakeup_pin: AnyInputPin, sleep_time: Duration) {
// //     // let wakeup_pin = PinDriver::input(wakeup_pin).expect("wakeup pin sleep");
// //     // unsafe {
// //     //     esp_idf_sys::esp_sleep_enable_ext0_wakeup(wakeup_pin.pin(), 0);
// //     // }
// //     info!("entering deep sleep");
// //     unsafe {
// //         // TODO: measure current draw vs gpio_deep_sleep_hold_en
// //         //esp_idf_sys::rtc_gpio_hold_en(led.pin());
// //         //esp_idf_sys::gpio_deep_sleep_hold_en()
// //         // TODO see if these need to be configured or if it makes a difference at all
// //         // esp_sleep_pd_config(ESP_PD_DOMAIN_RTC_PERIPH, ESP_PD_OPTION_OFF);
// //         // esp_sleep_pd_config(ESP_PD_DOMAIN_RTC_SLOW_MEM, ESP_PD_OPTION_OFF);
// //         // esp_sleep_pd_config(ESP_PD_DOMAIN_RTC_FAST_MEM, ESP_PD_OPTION_OFF);
// //         // esp_sleep_pd_config(ESP_PD_DOMAIN_XTAL, ESP_PD_OPTION_OFF);

// //         esp_idf_sys::esp_deep_sleep(sleep_time.as_micros() as u64);
// //     }
// //     // unreachable!("we will be asleep by now");
// // }

// // /// Disable the onboard led during deep sleep
// // /// TODO: measure current draw vs gpio_deep_sleep_hold_en
// // pub fn disable_onboard_led(ledpin: gpio::Gpio2) -> anyhow::Result<()> {
// //     log::info!("disable onboard led");
// //     let mut led = PinDriver::output(ledpin)?;
// //     led.set_low()?;
// //     unsafe {
// //         esp_idf_sys::rtc_gpio_hold_en(led.pin());
// //     }

// //     Ok(())
// // }

// // fn create_epd_driver(
// //     spi_p: spi::SPI3,
// //     sclk: AnyOutputPin,
// //     sdo: AnyOutputPin,
// //     _cs: AnyOutputPin,
// //     busy_in: AnyInputPin,
// //     rst: AnyOutputPin,
// //     dc: AnyOutputPin,
// // ) -> anyhow::Result<(SpiDev, EpdDriver, Delay)> {
// //     let mut driver = spi::SpiDeviceDriver::new_single(
// //         spi_p,
// //         sclk,
// //         sdo,
// //         Option::<gpio::AnyIOPin>::None,
// //         Option::<gpio::AnyOutputPin>::None,
// //         &spi::config::DriverConfig::new(),
// //         &spi::config::Config::new().baudrate(10.MHz().into()),
// //     )?;

// //     info!("driver setup completed");
// //     let mut delay = Delay::new_default();

// //     // Setup EPD
// //     let epd_driver = Epd7in5::new(
// //         &mut driver,
// //         PinDriver::input(busy_in)?,
// //         PinDriver::output(dc)?,
// //         PinDriver::output(rst)?,
// //         &mut delay,
// //         None,
// //     )
// //     .unwrap();

// //     info!("epd setup completed");

// //     Ok((driver, epd_driver, delay))
// // }

/// Retuns the size of a buffer necessary to hold the entire image
pub fn get_buffer_size() -> usize {
    // The height is multiplied by 2 because the red pixels essentially exist on a separate "layer"
    epd_waveshare::buffer_len(DISPLAY_WIDTH as usize, DISPLAY_HEIGHT as usize * 2)
}

// // fn draw_epd(
// //     mut buffer: Vec<u8>,
// //     mut driver: SpiDev,
// //     mut epd: EpdDriver,
// //     mut delay: Delay,
// // ) -> anyhow::Result<()> {
// //     let expected_len = get_buffer_size();

// //     // check that what we got from the server is actually the same size as when me make a
// //     // epd_waveshare buffer of size WIDTH*HEIGHT pixels
// //     let buffer_len = buffer.len();
// //     if buffer_len != expected_len {
// //         anyhow::bail!("buffer len expected {}, got {}", expected_len, buffer_len);
// //     }
// //     let display = VarDisplay::<TriColor>::new(DISPLAY_WIDTH, DISPLAY_HEIGHT, &mut buffer, false)
// //         .expect("failed to create display");

// //     epd.update_and_display_frame(&mut driver, display.buffer(), &mut delay)
// //         .expect("display frame");
// //     info!("called display frame");
// //     delay.delay_ms(20_000u32);

// //     info!("done waiting, putting display to sleep");
// //     epd.sleep(&mut driver, &mut delay).expect("failed to sleep");

// //     Ok(())
// // }

// #[entry]
// fn main() -> ! {
//     let peripherals = Peripherals::take();
//     let system = peripherals.SYSTEM.split();
//     let clocks = ClockControl::max(system.clock_control).freeze();
//     let mut delay = Delay::new(&clocks);

//     defmt::info!("Hello world pr!");
//     defmt::warn!("Hello world!");
//     loop {
//         defmt::info!("Hello world!");

//         // info!("Loop...");
//         delay.delay_ms(500u32);
//     }
// }
